#importonce
// IRQ handling routines
// references
// https://www.c64-wiki.com/wiki/Raster_interrupt
// http://theweb.dk/KickAssembler/webhelp/content/ch02s02.html

#import "screen.asm"

/*
    sorts out the irq raster interrupt
*/

.macro initIRQ(handlerFunction, rasterLine) {

    In:
        // set interrupt disable status
        sei
        jmp IRQSetup

    IRQHandler:
/*
        #if !HAS_KERNAL_ROM
            StoreRegisterState();
        #endif
*/
        lda #$ff
        AcknowledgeInterrupt();

        // this is the actual work
        jsr handlerFunction

        jmp $ea81
        /*
        #if HAS_KERNAL_ROM
            jmp $ea81
        #else
            RestoreRegsiterState();
            rti
        #endif
        */
    IRQSetup:

        /*
        Interrupt control and status register. Read bits:

        Bit #0: 1 = Timer A underflow occurred.
        Bit #1: 1 = Timer B underflow occurred.
        Bit #2: 1 = TOD is equal to alarm time.
        Bit #3: 1 = A complete byte has been received into or sent from serial shift register.
        Bit #4: Signal level on FLAG pin, datasette input.
        Bit #7: An interrupt has been generated.

        Write bits:

        Bit #0: 1 = Enable interrupts generated by timer A underflow.
        Bit #1: 1 = Enable interrupts generated by timer B underflow.
        Bit #2: 1 = Enable TOD alarm interrupt.
        Bit #3: 1 = Enable interrupts generated by a byte having been received/sent via serial shift register.
        Bit #4: 1 = Enable interrupts generated by positive edge on FLAG pin.
        Bit #7: Fill bit;   bits #0-#6, that are set to 1, get their values from this bit; 
                            bits #0-#6, that are set to 0, are left unchanged.
        */
        // set interupt triggers we are interested in
        lda #$7f // %111011
        sta $dc0d
        sta $dd0d

        /*
        Interrupt control register. Bits:

        Bit #0: 1 = Raster interrupt enabled.
        Bit #1: 1 = Sprite-background collision interrupt enabled.
        Bit #2: 1 = Sprite-sprite collision interrupt enabled.
        Bit #3: 1 = Light pen interrupt enabled.
        */
        // ensure we turn on Raster interrupts
		lda $d01a
		ora #%00000001	
		sta $d01a

        /*
        Screen control register #1. Bits:

        Bits #0-#2: Vertical raster scroll.
        Bit #3: Screen height; 0 = 24 rows; 1 = 25 rows.
        Bit #4: 0 = Screen off, complete screen is covered by border; 1 = Screen on, normal screen contents are visible.
        Bit #5: 0 = Text mode; 1 = Bitmap mode.
        Bit #6: 1 = Extended background mode on.
        Bit #7: Read: Current raster line (bit #8).
        Write: Raster line to generate interrupt at (bit #8).
        Default: $1B, %00011011.
        */
		lda $d011
		and #%01111111
		sta $d011	

        // set the raster scan line we want to trip on
        /*
        Read: Current raster line (bits #0-#7).
        Write: Raster line to generate interrupt at (bits #0-#7).
        */
        // which line of the screen
        lda #rasterLine
        sta $d012

        /*
        Execution address of interrupt service routine.
        Default: $EA31.
        */
        // store the new interrupt address
		lda #<IRQHandler
        sta $0314
        lda #>IRQHandler
        sta $0315

        // store a dummy NMI to avoid crashing due to RESTORE
        lda #<nmi
        sta $fffa
        lda #>nmi
        sta $fffb

        lda $dc0d
        lda $dd0d
        AcknowledgeInterrupt()

        // clear interrupt status flag
        cli
}

nmi: { rti }

// push all registers onto stack
.macro StoreRegisterState() {
    pha // push Acc on stack
    txa // transfer x to accumulator
    pha // push Acc(x) on stack
    tya // transfer y to accumulator
    pha // push Acc(y) on stack
}

// restore registers from stack, in reverse order
.macro RestoreRegsiterState() {
    pla // pull Acc from stack
    tay // transfer Acc(y) to y
    pla // pull Acc from stack
    tax // transfer Acc(x) to x
    pla // pull Acc from stack
}

.macro AcknowledgeInterrupt() {
    /*
    Interrupt status register. Read bits:

    Bit #0: 1 = Current raster line is equal to the raster line to generate interrupt at.
    Bit #1: 1 = Sprite-background collision occurred.
    Bit #2: 1 = Sprite-sprite collision occurred.
    Bit #3: 1 = Light pen signal arrived.
    Bit #7: 1 = An event (or more events), that may generate an interrupt, occurred and it has not been (not all of them have been) acknowledged yet.

    Write bits:

    Bit #0: 1 = Acknowledge raster interrupt.
    Bit #1: 1 = Acknowledge sprite-background collision interrupt.
    Bit #2: 1 = Acknowledge sprite-sprite collision interrupt.
    Bit #3: 1 = Acknowledge light pen interrupt.
    */
    // acknowledge the interrupt by shifting left and :. adding a zero at pos 0?
    // asl First writes 255 , followed by the "proper" value an instant later.
    asl $d019

}

